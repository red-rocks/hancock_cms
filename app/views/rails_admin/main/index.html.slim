ruby:
  query = params[:query]
  params = request.params.except(:authenticity_token, :action, :controller, :utf8, :bulk_export, :_pjax)
  params.delete(:query) if params[:query].blank?
  params.delete(:sort_reverse) unless params[:sort_reverse] == 'true'
  sort_reverse = params[:sort_reverse]
  sort = params[:sort]
  params.delete(:sort) if params[:sort] == @model_config.list.sort_by.to_s
  export_action = RailsAdmin::Config::Actions.find(:export, { controller: self.controller, abstract_model: @abstract_model })
  export_action = nil unless export_action && authorized?(export_action.authorization_key, @abstract_model)
  description = RailsAdmin.config(@abstract_model.model_name).description
  properties = @model_config.list.with(controller: self.controller, view: self, object: @abstract_model.model.new).visible_fields
  # columns paginate
  sets = get_column_sets(properties)
  properties = sets[params[:set].to_i] || []
  other_left = ((params[:set].to_i - 1) >= 0) && sets[params[:set].to_i - 1].present?
  other_right = sets[params[:set].to_i + 1].present?

.hancock-panel
  .content
    .head
      .head-label
        h2 = @abstract_model.param_key
      .toolbar
    .body
      - content_for :contextual_tabs do

        - if filterable_fields.present?
          li.dropdown
            a.dropdown-toggle{href='#' data-toggle="dropdown"}
              i.mdi.mdi-filter-plus
              /= t('admin.misc.add_filter')
              /b.caret
            ul.dropdown-menu#filters{style='left:auto; right:0;'}
              - filterable_fields.each do |field|
                - field_options = case field.type
                - when :enum
                  - options_for_select(field.with(object: @abstract_model.model.new).enum)
                - else
                  - ''
                li
                  ruby:
                    attrs = {
                      href: '#',
                      data: {
                        field_label: field.label,
                        field_name: field.name,
                        field_options: field_options.html_safe,
                        field_type: field.type,
                        field_value: "",
                        field_datetimepicker_format: (field.try(:parser) && field.parser.to_momentjs)
                      }
                    }
                  a{*attrs}= capitalize_first_letter(field.label)

        = hancock_bulk_menu
      style
        - properties.select{ |p| p.column_width.present? }.each do |property|
          = "#list th.#{property.css_class} { width: #{property.column_width}px; min-width: #{property.column_width}px; }"
          = "#list td.#{property.css_class} { max-width: #{property.column_width}px; }"

      = form_tag(url_for(params.except(*%w[page f query])), method: :get, class: "pjax-form form-inline") do
        .well
          .input-group
            input.form-control.input-small{name="query" type="search" value=query placeholder=t("admin.misc.filter")}
            span.input-group-btn
              - disabled_icon = '<i class="mdi mdi-refresh"></i> ' + t('admin.misc.refresh')
              button.btn.btn-primary.btn-with-icon{type='submit' data-disable-with=disabled_icon}
                i.mdi.mdi-refresh
                = t('admin.misc.refresh')
              button#remove_filter.btn.btn-info.icon-btn{title="Reset filters"}
                i.mdi.mdi-filter-remove

          span#filters_box{data-options=ordered_filter_options.to_json}
          hr.filters_box{style="display:#{ordered_filters.empty? ? 'none' : 'block'}"}

          - if export_action
            - export_path = export_path(params.except('set').except('page'))
            span{style='float:right'}= link_to wording_for(:link, export_action), export_path, class: 'btn btn-info'

      - unless @model_config.list.scopes.empty?
        ul.nav.nav-tabs#scope_selector
          - @model_config.list.scopes.uniq.each_with_index do |scope, index|
            - scope = '_all' if scope.nil?
            li{class="#{'active' if scope.to_s == params[:scope] || (params[:scope].blank? && index == 0)}"}
              - index_path = url_for(params.merge(scope: scope, page: nil))
              - index_title = I18n.t("admin.scopes.#{@abstract_model.to_param}.#{scope}", default: I18n.t("admin.scopes.#{scope}", default: scope.to_s.titleize))
              -# %a{href: index_path(params.merge(scope: scope, page: nil)), class: 'pjax'}= I18n.t("admin.scopes.#{@abstract_model.to_param}.#{scope}", default: I18n.t("admin.scopes.#{scope}", default: scope.to_s.titleize))
              a{href=index_path class='pjax'}= index_title

      = form_tag bulk_action_path(model_name: @abstract_model.to_param), method: :post, id: "bulk_form", class: "form" do
        = hidden_field_tag :bulk_action
        - if description.present?
          p
            strong= description

        table.table.table-condensed.table-striped.hancock-table
          thead
            tr
              th.shrink
                input.toggle{type="checkbox"}
              - if other_left
                th.other.left.shrink= "..."
              - properties.each do |property|
                - selected = (sort == property.name.to_s)
                - if property.sortable
                  -# - sort_location = index_path params.except('sort_reverse').except('page').merge(sort: property.name).merge(selected && sort_reverse != "true" ? {sort_reverse: "true"} : {})
                  - sort_location = url_for params.except('sort_reverse').except('page').merge(sort: property.name).merge(selected && sort_reverse != "true" ? {sort_reverse: "true"} : {})
                  - sort_direction = (sort_reverse == 'true' ? "headerSortUp" : "headerSortDown" if selected)
                ruby:
                  classes = [
                    (property.sortable && "header pjax" || nil),
                    (property.sortable && sort_direction && "sort_direction" || nil),
                    property.css_class,
                    property.type_css_class
                  ].compact
                  attrs = {
                    class: classes,
                    data: {
                      href: (property.sortable && sort_location)
                    },
                    title: property.label
                  }
                -#%th{class: "#{property.sortable && "header pjax" || nil} #{sort_direction if property.sortable && sort_direction} #{property.css_class} #{property.type_css_class}", :'data-href' => (property.sortable && sort_location), rel: "tooltip", title: "#{property.hint}"}= capitalize_first_letter(property.label)
                th{*attrs}= capitalize_first_letter(property.label)
              - if other_right
                th.other.right.shrink= "..."
              th.last.shrink
          tbody
            - @objects.each do |object|
              ruby:
                classes = [
                  "#{@abstract_model.param_key}_row",
                  "#{@model_config.list.with(object: object).row_css_class}",
                  ((params[:select] == object.id.to_s) && "selected" || nil)
                ].compact
              tr{class=classes}
                td
                  = check_box_tag "bulk_ids[]", object.id, false
                -# - if @other_left_link ||= other_left && index_path(params.except('set').merge(params[:set].to_i != 1 ? {set: (params[:set].to_i - 1)} : {}))
                - if @other_left_link ||= other_left && url_for(params.except('set').merge(params[:set].to_i != 1 ? {set: (params[:set].to_i - 1)} : {}))
                  td.other.left= link_to "...", @other_left_link, class: 'pjax'
                - properties.map{ |property| property.bind(:object, object) }.each do |property|
                  - value = property.pretty_value
                  td{class="#{property.css_class} #{property.type_css_class}", title=strip_tags(value.to_s)}= value
                -# - if @other_right_link ||= other_right && index_path(params.merge(set: (params[:set].to_i + 1)))
                -# - if @other_right_link = other_right && url_for(params.merge(set: (params[:set].to_i + 1)))
                -# - if @other_right_link = other_right && url_for(params.merge(set: (params[:set].to_i + 1), anchor: object.id))
                - if @other_right_link = other_right && url_for(params.merge(set: (params[:set].to_i + 1), select: object.id))
                  td.other.right= link_to "...", @other_right_link, class: 'pjax'
                td.last.links
                  ul.inline.list-inline= hancock_menu_for :member, @abstract_model, object, true
    .footer
      - if @objects.respond_to?(:total_count)
        - total_count = @objects.total_count.to_i
        .row
          .col-md-6= paginate(@objects, theme: 'ra-twitter-bootstrap', remote: true)
        .row
          .col-md-6= link_to(t("admin.misc.show_all"), url_for(params.merge(all: true)), class: "show-all btn btn-default pjax") unless total_count > 100 || total_count <= @objects.to_a.size

        .total-count= "#{total_count} #{@model_config.pluralize(total_count).downcase}"

      - else
        .total-count= "#{@objects.size} #{@model_config.pluralize(@objects.size).downcase}"
